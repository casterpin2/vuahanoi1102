import java.time.LocalDate;
import java.util.*;

public static void main(String[] args) {
    List<WorkEntry> workData = Arrays.asList(
            new WorkEntry("A", "2024-03-01", "2024-03-01", 8),
            new WorkEntry("A", "2024-03-04", "2024-03-04", 8),
            new WorkEntry("A", "2024-03-05", "2024-03-05", 8),
            new WorkEntry("B", "2024-03-06", "2024-03-08", 8)
    );

    List<BreakEntry> breakData = Arrays.asList(
            new BreakEntry("A", "2024-03-04", 3), // Ngày thường, nghỉ 3h -> làm 5h
            new BreakEntry("B", "2024-03-07", 2)  // Ngày thường, nghỉ 2h -> làm 6h
    );

    Set<LocalDate> holidays = new HashSet<>(Arrays.asList(
            LocalDate.parse("2024-03-06"), // Ví dụ ngày nghỉ lễ
            LocalDate.parse("2024-03-10")
    ));

    Map<String, TreeMap<LocalDate, Integer>> result = allocateWorkHours(workData, breakData, holidays);

    // Hiển thị kết quả
    for (Map.Entry<String, TreeMap<LocalDate, Integer>> entry : result.entrySet()) {
        System.out.println("PIC: " + entry.getKey());
        for (Map.Entry<LocalDate, Integer> dateEntry : entry.getValue().entrySet()) {
            System.out.println("  Date: " + dateEntry.getKey() + ", Total Hours: " + dateEntry.getValue());
        }
    }
}

public static Map<String, TreeMap<LocalDate, Integer>> allocateWorkHours(
        List<WorkEntry> workData, List<BreakEntry> breakData, Set<LocalDate> holidays) {

    Map<String, TreeMap<LocalDate, Integer>> workHoursMap = new HashMap<>();

    // **1. Chuyển breakData thành Map để truy xuất nhanh**
    Map<String, Map<LocalDate, Integer>> breakMap = new HashMap<>();
    for (BreakEntry b : breakData) {
        breakMap.putIfAbsent(b.pic, new HashMap<>());
        breakMap.get(b.pic).put(b.date, b.breakHours);
    }

    // **2. Gộp giờ làm vào workHoursMap**
    for (WorkEntry work : workData) {
        workHoursMap.putIfAbsent(work.pic, new TreeMap<>());
        TreeMap<LocalDate, Integer> dateHours = workHoursMap.get(work.pic);

        LocalDate date = work.dateFrom;
        while (!date.isAfter(work.dateTo)) {
            dateHours.put(date, dateHours.getOrDefault(date, 0) + work.hours);
            date = date.plusDays(1);
        }
    }

    // **3. Xử lý giờ nghỉ và dồn giờ dư**
    for (String pic : workHoursMap.keySet()) {
        TreeMap<LocalDate, Integer> dateHours = workHoursMap.get(pic);
        Queue<Map.Entry<LocalDate, Integer>> overflowQueue = new LinkedList<>();

        for (Map.Entry<LocalDate, Integer> entry : new TreeMap<>(dateHours).entrySet()) {
            LocalDate date = entry.getKey();
            int workHours = entry.getValue();

            // **Nếu có giờ nghỉ, giảm số giờ làm**
            int breakHours = breakMap.getOrDefault(pic, Collections.emptyMap()).getOrDefault(date, 0);
            int adjustedHours = Math.min(workHours, 8 - breakHours);

            // **Nếu có giờ dư, đưa vào queue để xử lý sau**
            if (workHours > adjustedHours) {
                overflowQueue.add(new AbstractMap.SimpleEntry<>(date.plusDays(1), workHours - adjustedHours));
            }

            // **Cập nhật số giờ làm sau khi trừ giờ nghỉ**
            dateHours.put(date, adjustedHours);
        }

        // **4. Dồn giờ dư sang ngày tiếp theo hợp lệ**
        while (!overflowQueue.isEmpty()) {
            Map.Entry<LocalDate, Integer> overflow = overflowQueue.poll();
            LocalDate nextDate = overflow.getKey();
            int remainingHours = overflow.getValue();

            while (remainingHours > 0) {
                // Nếu ngày tiếp theo là ngày nghỉ, nhảy qua ngày tiếp theo
                while (holidays.contains(nextDate)) {
                    nextDate = nextDate.plusDays(1);
                }

                int availableHours = dateHours.getOrDefault(nextDate, 0);
                int maxCanAdd = Math.min(8 - availableHours, remainingHours);

                if (maxCanAdd > 0) {
                    dateHours.put(nextDate, availableHours + maxCanAdd);
                    remainingHours -= maxCanAdd;
                }

                if (remainingHours > 0) {
                    nextDate = nextDate.plusDays(1);
                }
            }
        }
    }

    return workHoursMap;
}